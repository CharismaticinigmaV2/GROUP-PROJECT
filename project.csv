#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <fstream>
#include <string>
#include <sstream>
using namespace std;

// Define structures for Team and Fixture
struct Team {
    string name;
    string town;
    string stadium;
};

struct Fixture {
    Team homeTeam;
    Team awayTeam;
    int leg;
    int weekend;
};
// Function to read teams from a CSV file
vector<Team> readTeamsFromCSV(const string& filename) {
    vector<Team> teams;
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Error opening file: " << filename << endl;
        return teams;
    }

    string line;
    // Skip the header line
    getline(file, line);

    // Read each line and create Team objects
    while (getline(file, line)) {
        istringstream iss(line);
        string name, town, stadium;

        if (getline(iss, name, ',') &&
            getline(iss, town, ',') &&
            getline(iss, stadium, ',')) {
            teams.push_back({name, town, stadium});
        }
    }

    file.close();
    return teams;
}

// Function to generate fixtures for the teams
vector<Fixture> generateFixtures(const vector<Team>& teams) {
    vector<Fixture> fixtures;
    int totalWeekends = teams.size() - 1 * 2;
    int matchesPerWeekend = teams.size() / 5;

    // Generate home and away fixtures for each team pair
    for (int leg = 1; leg <= 2; ++leg) {
        for (int i = 0; i < teams.size() - 1; ++i) {
            for (int j = i + 1; j < teams.size(); ++j) {
                Fixture fixture;
                fixture.homeTeam = (leg == 1) ? teams[i] : teams[j];
                fixture.awayTeam = (leg == 1) ? teams[j] : teams[i];
                fixture.leg = leg;
                fixtures.push_back(fixture);
            }
        }
    }
  // Shuffle fixtures to randomize the order
    random_device rd;
    mt19937 g(rd());
    shuffle(fixtures.begin(), fixtures.end(), g);

    // Assign weekends to fixtures
    int currentWeekend = 1;
    int matchesThisWeekend = 0;

    for (auto& fixture : fixtures) {
        if (matchesThisWeekend == matchesPerWeekend) {
            currentWeekend++;
            matchesThisWeekend = 0;
        }
        fixture.weekend = currentWeekend;
        matchesThisWeekend++;
    }

    return fixtures;
}

// Function to save fixtures to a CSV file
void saveFixturesToCSV(const vector<Fixture>& fixtures, const string& filename) {
    ofstream file(filename);
    if (!file.is_open()) {
        cerr << "Error opening file: " << filename << endl;
        return;
    }

    // Write header
    file << "Weekend,Home Team,Away Team,Home Town,Away Town,Stadium,Leg\n";

    // Write fixture data
    for (const auto& fixture : fixtures) {
        file << fixture.weekend << ","
             << fixture.homeTeam.name << ","
             << fixture.awayTeam.name << ","
             << fixture.homeTeam.town << ","
             << fixture.awayTeam.town << ","
             << fixture.homeTeam.stadium << ","
             << fixture.leg << "\n";
    }

    file.close();
}

// Function to display fixtures on the console
void displayFixtures(const vector<Fixture>& fixtures) {
    for (const auto& fixture : fixtures) {
        cout << "Weekend #" << fixture.weekend << ": "
                  << fixture.homeTeam.name << " vs " << fixture.awayTeam.name
                  << " (Leg " << fixture.leg << ")\n"
                  << "  Stadium: " << fixture.homeTeam.stadium << " (" << fixture.homeTeam.town << ")\n"
                  << "  Away team from: " << fixture.awayTeam.town << "\n\n";
    }
}
    // Shuffle fixtures to randomize the order
    random_device rd;
    mt19937 g(rd());
    shuffle(fixtures.begin(), fixtures.end(), g);

